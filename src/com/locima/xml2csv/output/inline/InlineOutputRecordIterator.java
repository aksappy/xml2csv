package com.locima.xml2csv.output.inline;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.locima.xml2csv.BugException;
import com.locima.xml2csv.extractor.ContainerExtractionContext;
import com.locima.xml2csv.extractor.ExtractionContext;
import com.locima.xml2csv.extractor.MappingExtractionContext;
import com.locima.xml2csv.output.GroupState;
import com.locima.xml2csv.output.IExtractionResults;
import com.locima.xml2csv.output.IExtractionResultsContainer;
import com.locima.xml2csv.output.IExtractionResultsValues;
import com.locima.xml2csv.util.StringUtil;

/**
 * Iterates over a tree of {@link ContainerExtractionContext} to output a set of CSV output lines. This is where the hierarchical results of all the
 * extraction of data for a single document (modelled using {@link ExtractionContext} instances are finally flattened in to a set of records.
 * <p>
 * When initialised, this creates a linked list of {@link GroupState} objects that maintain the state of each group for multi-record mappings, and a
 * special group for all the inline mappings (group number isn't used for inline mappings).
 */
public class InlineOutputRecordIterator implements Iterator<List<ExtractedField>> {

	private static final Logger LOG = LoggerFactory.getLogger(InlineOutputRecordIterator.class);

	/**
	 * The group state with the lowest group number. Set up by {@link GroupState#createGroupStateList(java.util.Collection)} in {{@link #iterator()}.
	 * <p>
	 * {@link GroupState} is a linked list, so we only need to keep a reference to the head.
	 */
	private GroupState baseGroupState;

	/**
	 * The tree of rootContainer that this iterator is walking.
	 */
	private IExtractionResults rootContainer;

	/**
	 * Initalises a new iterator. Usually called by {@link ExtractedRecordList#iterator()}.
	 *
	 * @param rootContainer the set of rootContainer that we're going to iterate;
	 */
	public InlineOutputRecordIterator(IExtractionResults rootContainer) {
		this.rootContainer = rootContainer;
		this.baseGroupState = GroupState.createGroupStateList(rootContainer);
	}

	/**
	 * Adds to the passed <code>csvFields</code> list the relevant {@link ExtractedField} values found by this container.
	 *
	 * @param csvFields a list of fields being built up for a single output record.
	 * @param context the {@link ExtractionContext} the relevant (contained) values of which should be added to <code>csvFields</code>.
	 */
	private void createCsiFieldsFromContainer(List<ExtractedField> csvFields, IExtractionResultsContainer context) {
		switch (context.getMultiValueBehaviour()) {
			case GREEDY:
				int containerIterationCount = 0;
				int resultIndexForTrace = 0;
				List<List<IExtractionResults>> allResults = context.getChildren();
				for (List<IExtractionResults> results : allResults) {
					for (IExtractionResults child : results) {
						if (LOG.isDebugEnabled()) {
							LOG.debug("Greedy eval of child {}.{} ({}) from {}", containerIterationCount, resultIndexForTrace++, child, context);
						}
						createCsiRecord(csvFields, child);
					}
					containerIterationCount++;
					resultIndexForTrace = 0;
				}
				break;
			case LAZY:
				int valueIndex = getIndexForGroup(context.getGroupNumber());
				List<IExtractionResults> results = context.getResultsSetAt(valueIndex);
				for (IExtractionResults child : results) {
					LOG.debug("Lazy eval of child {} ({}) from {}", valueIndex++, child, context);
					createCsiRecord(csvFields, child);
				}
				break;
			case DEFAULT:
				throw new BugException("Found DEFAULT MultiValueBehaviour whilst transforming to output, this should have been resolved by "
								+ "Mapping.getMultiValueBehaviour().");
			default:
				throw new BugException("Found unexpected (%s) value in Mapping.getMultiValueBehaviour().", context.getMultiValueBehaviour());
		}
	}

	/**
	 * Adds the fields generated by a single {@link MappingExtractionContext}, taking in to account multi-value behaviour and minimum numbers of
	 * fields.
	 *
	 * @param csvFields the ordered list of CSV fields to add to.
	 * @param context the context to extract the values from.
	 */
	private void createCsiFieldsFromMapping(List<ExtractedField> csvFields, IExtractionResultsValues context) {
		int[] fieldPositionPrefix = getPrefix(context);
		switch (context.getMultiValueBehaviour()) {
			case GREEDY:
				/* Greedy mappings output as much as they can */
				List<String> fieldValues = context.getAllValues();
				List<ExtractedField> fields = createExtractedFields(fieldValues);
				if (LOG.isDebugEnabled()) {
					LOG.debug("Greedily adding all fields {} to as output of {}", StringUtil.collectionToString(fields, ", ", null), context);
				}
				csvFields.addAll(fields);
				break;
			case LAZY:
				/* The most typical option: just process the next value and move on */
				int valueIndex = getIndexForGroup(context.getMapping().getGroupNumber());
				String fieldValue = context.getValueAt(valueIndex);
				ExtractedField field = createExtractedField(fieldPositionPrefix, valueIndex, fieldValue);
				LOG.debug("Lazy eval of child {} ({}) from {}", valueIndex, field, context);
				csvFields.add(field);
				break;
			case DEFAULT:
				throw new BugException("Found DEFAULT MultiValueBehaviour whilst transforming to output, this should have been resolved by "
								+ "Mapping.getMultiValueBehaviour().");
			default:
				throw new BugException("Found unexpected (%s) value in Mapping.getMultiValueBehaviour().", context.getMultiValueBehaviour());
		}
	}

	/**
	 * Creates a list of values, ready to be output in to a CSV file.
	 *
	 * @return a possibly empty string containing a mixture of null and non-null values.
	 */
	private List<ExtractedField> createCsiRecord() {
		List<ExtractedField> csiRecord = new ArrayList<ExtractedField>();

		createCsiRecord(csiRecord, this.rootContainer);

		if (LOG.isDebugEnabled()) {
			LOG.debug("Created CSI record as follows ({})", StringUtil.collectionToString(csiRecord, ",", null));
		}
		return csiRecord;
	}

	private void createCsiRecord(List<ExtractedField> csvFields, IExtractionResults context) {
		// BUG Fix this, it's horrible code, the interfaces should be different or it should be irrelevant.
		if (context instanceof IExtractionResultsContainer) {
			createCsiFieldsFromContainer(csvFields, (IExtractionResultsContainer) context);
		} else {
			createCsiFieldsFromMapping(csvFields, (IExtractionResultsValues) context);
		}
	}

	private ExtractedField createExtractedField(int[] prefix, int valueIndex, String fieldValue) {
		int originalLen = prefix.length;
		int[] fieldPos = new int[originalLen + 1];
		System.arraycopy(prefix, 0, fieldPos, 0, originalLen);
		fieldPos[originalLen] = valueIndex;
		return new ExtractedField(fieldPos, fieldValue);
	}

	private List<ExtractedField> createExtractedFields(List<String> fieldValues) {
		if (fieldValues == null) {
			return null;
		}
		List<ExtractedField> fields = new ArrayList<ExtractedField>(fieldValues.size());
		int index = 0;
		for (String value : fieldValues) {
			fields.add(createExtractedField(null, index, value));
			index++;
		}
		return fields;
	}

	/**
	 * Determines the current index of the passed <code>group<code> in the rootContainer set iteration.
	 *
	 * @param group the group to get the current index of. Must be a valid group.
	 * @return the index of the result to return (min 0, unbounded max)
	 */
	private int getIndexForGroup(int group) {
		GroupState existingGroup = this.baseGroupState.findByGroup(group);
		if (existingGroup == null) {
			throw new BugException("Tried to get index for non-existant group %d", group);
		}
		return existingGroup.getCurrentIndex();
	}

	private int[] getPrefix(IExtractionResultsValues context) {
		throw new UnsupportedOperationException("Not implemented yet, not sure what the structure will represent");
	}

	/**
	 * Determines whether there are any more records to iterate over based on whether all of the mappings have had all their outputs returned from the
	 * iterator.
	 *
	 * @return true if calling {@link #next()} would yield a record, false otherwise.
	 */
	@Override
	public boolean hasNext() {
		return (this.baseGroupState == null) ? false : this.baseGroupState.hasNext();
	}

	/**
	 * Moves on to the next record, preparing the CSV values and returning them.
	 */
	@Override
	public List<ExtractedField> next() {
		if (!hasNext()) {
			throw new NoSuchElementException();
		}
		List<ExtractedField> values = createCsiRecord();
		this.baseGroupState.increment();
		return values;
	}

	/**
	 * Not supported, so will throw {@link UnsupportedOperationException}.
	 */
	@Override
	public void remove() {
		throw new UnsupportedOperationException("remove() should never be called on ExtractedRecordList: " + this);
	}

}
